# Implementation Plan: Urdu Translation, Text Summarization, and Personalization

**Branch**: `5-urdu-translation-personalization` | **Date**: 2025-12-18 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/5-urdu-translation-personalization/spec.md`

## Summary

This feature enhances the RAG chatbot experience by enabling:
1. **Urdu Translation**: Users can translate selected book text and chatbot responses to Urdu with RTL formatting
2. **Text Summarization**: Users can summarize complex technical sections into concise 3-5 sentence summaries
3. **Interest-Based Personalization**: Users select interests (Robotics, AI/ML, Software Engineering, etc.) and receive chatbot responses with relevant analogies and examples

**Technical Approach**:
- Backend-only transformations (no client-side processing)
- Translation via external API (Google Translate or Azure Translator)
- Summarization and personalization via existing LLM (Cohere/OpenAI)
- User interests stored in Neon PostgreSQL database
- All transformations are runtime operations (no vector database modifications)

## Technical Context

**Language/Version**: Python 3.11
**Primary Dependencies**: FastAPI, Cohere SDK, httpx (for translation API), psycopg2/asyncpg (Neon PostgreSQL)
**Storage**: Neon PostgreSQL (for user profiles and interests)
**Testing**: pytest with async support, integration tests for API endpoints
**Target Platform**: Linux server (deployed on Vercel or similar)
**Project Type**: Web (backend + frontend)
**Performance Goals**:
- Translation: <5 seconds for 1000-word passages
- Summarization: <3 seconds for 500-word passages
- Personalization: <500ms additional latency on chat responses
- Concurrent requests: Support 100 simultaneous translation/summarization requests

**Constraints**:
- Must not modify original book content or vector embeddings
- Translation/summarization are ephemeral (not stored permanently)
- Technical terms and code must be preserved during translation
- Personalized responses must maintain 100% factual accuracy

**Scale/Scope**:
- 8 predefined interest categories
- Users select 2-5 interests
- Expected: 1,000+ users, 10,000+ translation/summarization requests daily
- Book content: ~200 chapters across 4 modules

## Constitution Check

✅ **Technical Accuracy & Scientific Rigor**: Translation and summarization preserve technical accuracy; personalization maintains factual correctness from RAG responses

✅ **Modularity & Scalability**: Features are modular (translation, summarization, personalization can be developed/deployed independently)

✅ **Code & Simulation Standards**: All Python code follows PEP 8, includes error handling, no hardcoded secrets

✅ **Quality Gates & Validation**: All endpoints include input validation, error handling, and logging; integration tests required before deployment

**No Constitution Violations**: This feature aligns with all core principles.

## Project Structure

### Documentation (this feature)

```text
specs/5-urdu-translation-personalization/
├── plan.md              # This file
├── spec.md              # Feature specification
├── data-model.md        # Database schema and API contracts
├── quickstart.md        # Setup and testing guide
├── contracts/           # API endpoint specifications
│   ├── translate-endpoint.md
│   ├── summarize-endpoint.md
│   ├── interests-endpoint.md
│   └── personalize-chat-endpoint.md
├── checklists/          # Quality validation
│   └── requirements.md
└── tasks.md             # Generated by /sp.tasks (not yet created)
```

### Source Code (repository root)

```text
backend/
├── main.py              # FastAPI app (add new endpoints here)
├── models.py            # Pydantic models (add new request/response models)
├── agent_config.py      # Agent configuration (extend for personalization)
├── tools.py             # Utility functions (add translation/summarization helpers)
├── services/            # NEW: Business logic services
│   ├── __init__.py
│   ├── translation_service.py     # Translation logic
│   ├── summarization_service.py   # Summarization logic
│   └── personalization_service.py # Personalization logic
├── database/            # NEW: Database layer
│   ├── __init__.py
│   ├── connection.py    # Neon PostgreSQL connection
│   ├── models.py        # SQLAlchemy models
│   └── repositories.py  # Data access layer
├── tests/               # NEW: Test suite
│   ├── test_translation.py
│   ├── test_summarization.py
│   ├── test_personalization.py
│   └── test_integration.py
└── .env                 # Add NEON_DATABASE_URL, TRANSLATION_API_KEY

frontend/
├── website/
│   ├── src/
│   │   ├── components/
│   │   │   ├── ChatKit/          # Extend with translation/summarization buttons
│   │   │   │   ├── TranslateButton.tsx   # NEW
│   │   │   │   ├── SummarizeButton.tsx   # NEW
│   │   │   │   └── ...
│   │   │   └── InterestSelector/  # NEW: Interest selection component
│   │   │       ├── index.tsx
│   │   │       └── InterestSelector.module.css
│   │   ├── contexts/
│   │   │   └── UserContext.tsx    # NEW: User profile and interests context
│   │   └── lib/
│   │       ├── translationApi.ts  # NEW: Translation API client
│   │       ├── summarizationApi.ts # NEW: Summarization API client
│   │       └── userApi.ts         # NEW: User interests API client
│   └── ...
```

**Structure Decision**: Web application structure selected because this feature spans both backend (API endpoints, database) and frontend (UI components for translation/summarization/interests). Backend handles all transformations; frontend provides UI controls and displays results.

## Complexity Tracking

> **No violations identified** - All complexity within constitution guidelines

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| N/A | N/A | N/A |

## Architecture Overview

### System Components

```
┌─────────────────────────────────────────────────────────────────┐
│                          Frontend (React/Docusaurus)            │
│  ┌──────────────┐  ┌──────────────┐  ┌───────────────────┐    │
│  │ ChatKit      │  │ Interest     │  │ Book Reading      │    │
│  │ Components   │  │ Selector     │  │ Components        │    │
│  │              │  │              │  │                   │    │
│  │ - Translate  │  │ - Checkbox   │  │ - Text Selection  │    │
│  │ - Summarize  │  │ - Save       │  │ - Translate Btn   │    │
│  │ - Display    │  │ - Update     │  │ - Summarize Btn   │    │
│  └──────┬───────┘  └──────┬───────┘  └─────────┬─────────┘    │
│         │                 │                    │                │
└─────────┼─────────────────┼────────────────────┼────────────────┘
          │                 │                    │
          │ HTTPS           │ HTTPS              │ HTTPS
          │                 │                    │
┌─────────▼─────────────────▼────────────────────▼────────────────┐
│                      Backend (FastAPI)                           │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    API Endpoints                         │  │
│  │  /translate        /summarize       /interests           │  │
│  │  /agent/chat (extended with personalization)            │  │
│  └────┬──────────────────┬────────────────┬─────────────────┘  │
│       │                  │                │                    │
│  ┌────▼──────────┐  ┌────▼───────────┐  ┌▼──────────────────┐  │
│  │ Translation   │  │ Summarization  │  │ Personalization  │  │
│  │ Service       │  │ Service        │  │ Service          │  │
│  │               │  │                │  │                  │  │
│  │ - Call API    │  │ - Call LLM     │  │ - Fetch Interests│  │
│  │ - Preserve    │  │ - Extract      │  │ - Inject Context │  │
│  │   Code/Terms  │  │   Key Points   │  │ - Generate       │  │
│  └───────┬───────┘  └────────┬───────┘  └───────┬──────────┘  │
│          │                   │                   │              │
│          │                   │                   │              │
│  ┌───────▼────────────────────▼───────────────────▼──────────┐  │
│  │              External Dependencies                        │  │
│  │  ┌─────────────┐  ┌──────────────┐  ┌─────────────────┐ │  │
│  │  │ Translation │  │ LLM API      │  │ Neon PostgreSQL │ │  │
│  │  │ API         │  │ (Cohere)     │  │                 │ │  │
│  │  │ (Google/    │  │              │  │ user_profiles   │ │  │
│  │  │  Azure)     │  │ - Summarize  │  │ user_interests  │ │  │
│  │  │             │  │ - Personalize│  │                 │ │  │
│  │  └─────────────┘  └──────────────┘  └─────────────────┘ │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow

**1. Translation Flow**:
```
User selects text → Frontend sends POST /translate with {text, target_lang}
→ Backend calls Translation API → Preserves code/terms → Returns {translated_text, original_text}
→ Frontend displays with RTL formatting → User can toggle back to original
```

**2. Summarization Flow**:
```
User selects text → Frontend sends POST /summarize with {text, max_length}
→ Backend validates length (50-5000 words) → Calls LLM with summarization prompt
→ LLM generates 20-30% length summary → Returns {summary, word_count_original, word_count_summary}
→ Frontend displays summary in modal/overlay
```

**3. Interest Selection Flow**:
```
User signs up/logs in → Frontend shows interest selector (8 categories, select 2-5)
→ User selects interests → POST /interests/save with {user_id, interest_ids[]}
→ Backend validates (2-5 interests) → Saves to PostgreSQL user_interests table
→ Returns {success, selected_interests} → Frontend updates UserContext
```

**4. Personalized Chat Flow**:
```
User sends chat message → Frontend includes user_id in POST /agent/chat
→ Backend fetches user interests from DB → Constructs personalized system prompt
→ System prompt: "User has interests in [X, Y, Z]. Use relevant analogies..."
→ RAG retrieval (unchanged) → Agent generates response with personalization
→ Response includes domain-specific examples → Returns to frontend
```

## Implementation Phases

### Phase 0: Research & Setup (Estimated: 1-2 days)

**Objectives**:
- Set up Neon PostgreSQL database
- Research translation API options (Google Translate vs Azure Translator)
- Design database schema for user interests
- Create API contracts for all endpoints

**Deliverables**:
- `data-model.md`: Complete database schema and API contracts
- `quickstart.md`: Setup instructions for local development
- `contracts/`: Individual endpoint specifications
- Database migrations for user_profiles and user_interests tables

**Key Decisions**:
- Translation API selection (recommend Google Translate for cost/ease)
- Database schema design (normalized vs denormalized user_interests)
- Authentication integration (ensure better-auth is available)

**Research Questions**:
1. Does better-auth already provide user_id that we can reference?
2. What is the Neon PostgreSQL connection string format?
3. Does Google Translate API support Urdu with good quality for technical content?
4. What is the token limit for Cohere summarization?

---

### Phase 1: Database & User Interests (Priority: P2)

**Objectives**:
- Set up Neon PostgreSQL connection
- Create user_interests table schema
- Implement user interests CRUD endpoints
- Build frontend InterestSelector component

**Tasks**:
- Create `database/connection.py` with async Neon PostgreSQL connection pool
- Define SQLAlchemy models for user_profiles and user_interests
- Implement repository pattern for data access
- Create POST /interests/save endpoint (save 2-5 interests for user)
- Create GET /interests/{user_id} endpoint (fetch user's interests)
- Create PATCH /interests/{user_id} endpoint (update interests)
- Build React InterestSelector component with checkboxes (8 categories)
- Integrate InterestSelector into sign-up flow
- Add interest management to user profile settings page
- Write integration tests for interests endpoints

**Acceptance Criteria**:
- User can select 2-5 interests during sign-up
- Interests are persisted to Neon PostgreSQL
- User can view/update interests in profile settings
- API validates 2-5 interest constraint
- All endpoints return proper error messages for invalid input

---

### Phase 2: Translation Service (Priority: P1)

**Objectives**:
- Integrate translation API (Google Translate or Azure Translator)
- Implement /translate endpoint
- Preserve code blocks and technical terms during translation
- Add frontend translation UI controls

**Tasks**:
- Create `services/translation_service.py` with Translation API client
- Implement text preprocessing to extract code blocks and terms
- Create POST /translate endpoint with request validation
- Add translation result caching (optional: Redis or in-memory for 1hr)
- Implement RTL text detection and formatting
- Build TranslateButton component (appears on text selection)
- Add "Show Original" toggle to translated text
- Handle translation errors gracefully (show error, preserve original)
- Write unit tests for translation service
- Write integration tests for /translate endpoint
- Test with technical robotics content (formulas, code, terminology)

**Acceptance Criteria**:
- Users can translate 1000-word passages in <5 seconds
- Code blocks remain unchanged in translation
- Technical terms (ROS 2, kinematics, etc.) are preserved or transliterated
- RTL formatting applied correctly to Urdu text
- Translation failures show user-friendly error messages
- 95%+ technical accuracy in translations (manual QA sampling)

---

### Phase 3: Summarization Service (Priority: P1)

**Objectives**:
- Implement LLM-based text summarization
- Create /summarize endpoint
- Add frontend summarization UI controls

**Tasks**:
- Create `services/summarization_service.py` with LLM client (Cohere)
- Design summarization prompt (focus on key concepts, exclude code)
- Implement word count validation (50-5000 words)
- Create POST /summarize endpoint
- Calculate summary length (target 20-30% of original)
- Build SummarizeButton component (appears on text selection)
- Display summary in modal or expandable section
- Add "Summarize Response" button to chatbot responses
- Handle short text gracefully (inform user text is already concise)
- Write unit tests for summarization service
- Write integration tests for /summarize endpoint
- Test summarization quality on technical content

**Acceptance Criteria**:
- Users can summarize 500-word passages in <3 seconds
- Summaries are 20-30% of original length
- Summaries focus on key concepts, not code syntax
- Short text (<100 words) triggers appropriate message
- Summarization works for both book content and chatbot responses

---

### Phase 4: Personalization Service (Priority: P2)

**Objectives**:
- Extend /agent/chat endpoint with personalization logic
- Inject user interests into agent context
- Generate responses with relevant analogies and examples

**Tasks**:
- Create `services/personalization_service.py` with interest-based prompt builder
- Fetch user interests from database during chat request
- Design personalization system prompt templates for each interest category
- Inject interest context into agent's system message (before RAG retrieval)
- Extend `agent_config.py` to support dynamic system prompts
- Update /agent/chat endpoint to include user_id and fetch interests
- Implement fallback to generic responses if no interests set
- Add logging/analytics to track personalization usage
- Write unit tests for personalization prompt construction
- Write integration tests comparing personalized vs generic responses
- Conduct QA testing: verify factual accuracy preservation

**Acceptance Criteria**:
- Personalized responses include ≥1 relevant analogy in 80% of cases
- Factual accuracy matches original RAG responses (100%)
- Personalization adds <500ms latency to chat response time
- Users without interests receive generic responses (no errors)
- Personalized examples are relevant to selected interest domains

---

### Phase 5: Combined Features & Frontend Integration (Priority: P3)

**Objectives**:
- Enable translation of personalized chatbot responses
- Integrate all features into cohesive UI experience
- Polish UI/UX for all features

**Tasks**:
- Add TranslateButton to personalized chatbot responses
- Test translation of responses containing personalized analogies
- Ensure technical terms remain preserved in translated personalized responses
- Update ChatContext to manage user interests state
- Add visual indicators for personalized responses (optional: badge/icon)
- Implement client-side caching of translations (session storage)
- Polish TranslateButton and SummarizeButton styling (match book theme)
- Add keyboard shortcuts for translate/summarize (optional: Ctrl+T, Ctrl+S)
- Write end-to-end integration tests for combined workflows
- Conduct user acceptance testing (UAT) with sample users

**Acceptance Criteria**:
- Users can translate personalized responses to Urdu
- All features work seamlessly together without conflicts
- UI is intuitive and consistent with existing design
- No performance degradation when using multiple features simultaneously

---

### Phase 6: Testing, Documentation & Deployment (Final)

**Objectives**:
- Comprehensive testing of all features
- Performance optimization
- Documentation updates
- Production deployment

**Tasks**:
- Run full test suite (unit, integration, end-to-end)
- Performance testing: simulate 100 concurrent translation/summarization requests
- Load testing: verify <5sec response time under load
- Security audit: validate input sanitization, SQL injection prevention
- Update API documentation (OpenAPI/Swagger)
- Write user-facing documentation (how to use features)
- Update environment variable documentation (.env.example)
- Create database migration scripts for production
- Deploy to Vercel/production environment
- Monitor error rates and performance metrics post-deployment
- Create rollback plan in case of critical issues

**Acceptance Criteria**:
- All tests passing (100% critical paths covered)
- Performance meets success criteria (SC-001 through SC-008)
- Documentation is complete and up-to-date
- Production deployment successful with zero downtime
- Error monitoring and alerting configured

---

## API Contracts

### POST /translate

**Request**:
```json
{
  "text": "ROS 2 nodes communicate via publish-subscribe pattern...",
  "target_lang": "ur",  // Urdu
  "preserve_code": true,
  "user_id": "optional-for-logging"
}
```

**Response**:
```json
{
  "translated_text": "ROS 2 nodes publish-subscribe pattern کے ذریعے بات چیت کرتے ہیں...",
  "original_text": "ROS 2 nodes communicate via publish-subscribe pattern...",
  "detected_lang": "en",
  "word_count": 156,
  "translation_time_ms": 1420
}
```

### POST /summarize

**Request**:
```json
{
  "text": "Long technical paragraph about kinematics...",
  "target_length": "short",  // short, medium, long
  "focus": "concepts",  // concepts, code, both
  "user_id": "optional-for-logging"
}
```

**Response**:
```json
{
  "summary": "Kinematics describes robot motion using joint angles...",
  "original_word_count": 450,
  "summary_word_count": 120,
  "compression_ratio": 0.27,
  "processing_time_ms": 2100
}
```

### POST /interests/save

**Request**:
```json
{
  "user_id": "user-uuid-from-better-auth",
  "interests": ["robotics", "software_engineering", "ai_ml"],
  "background": "student"  // student, professional
}
```

**Response**:
```json
{
  "success": true,
  "user_id": "user-uuid",
  "interests": [
    {"id": 1, "name": "Robotics"},
    {"id": 2, "name": "Software Engineering"},
    {"id": 3, "name": "AI/ML"}
  ],
  "background": "student"
}
```

### GET /interests/{user_id}

**Response**:
```json
{
  "user_id": "user-uuid",
  "interests": ["robotics", "software_engineering", "ai_ml"],
  "background": "student",
  "updated_at": "2025-12-18T10:30:00Z"
}
```

### POST /agent/chat (Extended)

**Request**:
```json
{
  "message": "How do ROS 2 nodes communicate?",
  "session_id": "session-uuid",
  "user_id": "user-uuid",  // NEW: for personalization
  "context_text": null
}
```

**Response**:
```json
{
  "response": "ROS 2 nodes communicate using a publish-subscribe pattern, similar to microservices architecture in software engineering. Think of it like Kafka or RabbitMQ... [personalized content]",
  "session_id": "session-uuid",
  "status": "success",
  "personalized": true,  // NEW: indicates personalization applied
  "interests_used": ["software_engineering"]  // NEW: shows which interests influenced response
}
```

---

## Database Schema

### Table: user_profiles

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| user_id | UUID | PRIMARY KEY | From better-auth |
| background | ENUM('student', 'professional') | NOT NULL | User's background level |
| created_at | TIMESTAMP | NOT NULL DEFAULT NOW() | Account creation time |
| updated_at | TIMESTAMP | NOT NULL DEFAULT NOW() | Last update time |

### Table: interest_categories

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | SERIAL | PRIMARY KEY | Interest category ID |
| name | VARCHAR(100) | UNIQUE NOT NULL | Category name |
| slug | VARCHAR(100) | UNIQUE NOT NULL | URL-friendly name |

**Seed Data**:
```sql
INSERT INTO interest_categories (name, slug) VALUES
('Robotics', 'robotics'),
('AI/ML', 'ai_ml'),
('Software Engineering', 'software_engineering'),
('Mechanical Engineering', 'mechanical_engineering'),
('Electrical Engineering', 'electrical_engineering'),
('Mathematics', 'mathematics'),
('Physics', 'physics');
```

### Table: user_interests

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | SERIAL | PRIMARY KEY | Record ID |
| user_id | UUID | FOREIGN KEY → user_profiles(user_id) | User reference |
| interest_id | INT | FOREIGN KEY → interest_categories(id) | Interest reference |
| created_at | TIMESTAMP | NOT NULL DEFAULT NOW() | When interest was selected |

**Indexes**:
```sql
CREATE INDEX idx_user_interests_user_id ON user_interests(user_id);
CREATE UNIQUE INDEX idx_user_interests_unique ON user_interests(user_id, interest_id);
```

**Constraints**:
```sql
ALTER TABLE user_interests
ADD CONSTRAINT chk_user_interests_count
CHECK (
  (SELECT COUNT(*) FROM user_interests WHERE user_id = user_id) BETWEEN 2 AND 5
);
```

---

## Environment Variables

```env
# Existing
COHERE_API_KEY=your-cohere-api-key
QDRANT_API_KEY=your-qdrant-api-key
QDRANT_URL=your-qdrant-url
OPENAI_API_KEY=your-openai-key

# NEW for Translation, Summarization, Personalization
NEON_DATABASE_URL=postgresql://user:password@host/dbname
TRANSLATION_API_KEY=your-google-translate-key  # or Azure
TRANSLATION_API_URL=https://translation.googleapis.com/language/translate/v2
ENABLE_TRANSLATION=true
ENABLE_SUMMARIZATION=true
ENABLE_PERSONALIZATION=true
```

---

## Risk Assessment & Mitigation

| Risk | Impact | Probability | Mitigation Strategy |
|------|--------|-------------|---------------------|
| Translation API rate limits exceeded | High | Medium | Implement request throttling, caching, fallback to queue |
| Translation quality poor for technical terms | High | Medium | Pre-process text to preserve terms, QA sampling, user feedback |
| LLM summarization introduces inaccuracies | High | Low | Strict prompt engineering, factual grounding, QA testing |
| Personalization reduces factual accuracy | High | Low | Validation tests, A/B comparison with original responses |
| Database connection pool exhaustion | Medium | Low | Configure connection limits, connection pooling with retry |
| Better-auth integration issues | Medium | Medium | Early integration testing, fallback to allow unauthenticated usage |
| Translation API costs exceed budget | Medium | Medium | Monitor usage, set daily limits, implement caching |
| RTL formatting breaks UI layout | Low | Medium | Comprehensive browser testing, CSS isolation |

---

## Testing Strategy

### Unit Tests
- Translation service: code preservation, term preservation, error handling
- Summarization service: length calculation, prompt construction
- Personalization service: interest context injection, prompt templates
- Database repositories: CRUD operations, constraint validation

### Integration Tests
- /translate endpoint: end-to-end translation workflow
- /summarize endpoint: end-to-end summarization workflow
- /interests endpoints: CRUD operations with database
- /agent/chat with personalization: interest-based response variation

### End-to-End Tests
- User sign-up with interest selection
- Book reading with text selection → translate → show original
- Chat with personalization → translate response
- Interest update → verify reflected in next chat response

### Performance Tests
- Translation: 1000-word passage in <5 seconds
- Summarization: 500-word passage in <3 seconds
- Personalization: <500ms additional latency
- Concurrent requests: 100 simultaneous translations without degradation

### Manual QA Tests
- Translation accuracy for technical content (sample 50 passages)
- Summarization quality (compare with human-written summaries)
- Personalization relevance (verify analogies match interests)
- UI/UX testing (text selection, button placement, RTL rendering)

---

## Deployment Checklist

- [ ] All environment variables configured in production
- [ ] Neon PostgreSQL database created and migrations applied
- [ ] Translation API key validated and quota confirmed
- [ ] Database connection pool configured for production load
- [ ] CORS origins updated for production domain
- [ ] API rate limiting configured
- [ ] Error monitoring and alerting enabled (Sentry, etc.)
- [ ] Performance monitoring enabled (request duration, success rate)
- [ ] Database backups configured
- [ ] Rollback plan documented and tested
- [ ] User-facing documentation published
- [ ] API documentation updated (Swagger/OpenAPI)

---

## Success Metrics (Post-Deployment)

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Translation response time (p95) | <5 seconds | APM monitoring |
| Summarization response time (p95) | <3 seconds | APM monitoring |
| Translation technical accuracy | ≥95% | QA sampling (50 passages/week) |
| Personalization response time | <500ms added latency | APM monitoring |
| Factual accuracy preservation | 100% | Automated validation + QA |
| Feature adoption rate (translation) | ≥30% of users try within 7 days | Analytics tracking |
| Feature stickiness (reuse) | ≥80% reuse in subsequent sessions | Analytics tracking |
| User satisfaction (personalization) | ≥70% positive feedback | Surveys (monthly) |
| Error rate (all endpoints) | <1% | Error monitoring |
| Concurrent request handling | 100 simultaneous without degradation | Load testing |

---

## Next Steps

1. **Immediate**: Run `/sp.tasks` to generate detailed task breakdown
2. **Phase 0**: Begin research and setup (database, API selection)
3. **Phase 1**: Implement user interests (foundational for P2 features)
4. **Phase 2 & 3**: Implement translation and summarization (P1 features, can be parallel)
5. **Phase 4**: Implement personalization (depends on Phase 1)
6. **Phase 5 & 6**: Integration, testing, deployment

**Estimated Total Timeline**: 3-4 weeks for full implementation and testing
